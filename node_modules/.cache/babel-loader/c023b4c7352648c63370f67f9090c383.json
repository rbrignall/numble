{"ast":null,"code":"import { objectWithoutPropertiesLoose as _objectWithoutPropertiesLoose, extends as _extends, createForOfIteratorHelperLoose as _createForOfIteratorHelperLoose } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport { Fragment, isValidElement, cloneElement, createElement, forwardRef } from 'react';\nimport { match } from './match.esm.js';\nvar Features;\n\n(function (Features) {\n  /** No features at all */\n  Features[Features[\"None\"] = 0] = \"None\";\n  /**\r\n   * When used, this will allow us to use one of the render strategies.\r\n   *\r\n   * **The render strategies are:**\r\n   *    - **Unmount**   _(Will unmount the component.)_\r\n   *    - **Hidden**    _(Will hide the component using the [hidden] attribute.)_\r\n   */\n\n  Features[Features[\"RenderStrategy\"] = 1] = \"RenderStrategy\";\n  /**\r\n   * When used, this will allow the user of our component to be in control. This can be used when\r\n   * you want to transition based on some state.\r\n   */\n\n  Features[Features[\"Static\"] = 2] = \"Static\";\n})(Features || (Features = {}));\n\nvar RenderStrategy;\n\n(function (RenderStrategy) {\n  RenderStrategy[RenderStrategy[\"Unmount\"] = 0] = \"Unmount\";\n  RenderStrategy[RenderStrategy[\"Hidden\"] = 1] = \"Hidden\";\n})(RenderStrategy || (RenderStrategy = {}));\n\nfunction render(_ref) {\n  var props = _ref.props,\n      slot = _ref.slot,\n      defaultTag = _ref.defaultTag,\n      features = _ref.features,\n      _ref$visible = _ref.visible,\n      visible = _ref$visible === void 0 ? true : _ref$visible,\n      name = _ref.name; // Visible always render\n\n  if (visible) return _render(props, slot, defaultTag, name);\n  var featureFlags = features != null ? features : Features.None;\n\n  if (featureFlags & Features.Static) {\n    var _props$static = props[\"static\"],\n        isStatic = _props$static === void 0 ? false : _props$static,\n        rest = _objectWithoutPropertiesLoose(props, [\"static\"]); // When the `static` prop is passed as `true`, then the user is in control, thus we don't care about anything else\n\n\n    if (isStatic) return _render(rest, slot, defaultTag, name);\n  }\n\n  if (featureFlags & Features.RenderStrategy) {\n    var _match;\n\n    var _props$unmount = props.unmount,\n        unmount = _props$unmount === void 0 ? true : _props$unmount,\n        _rest = _objectWithoutPropertiesLoose(props, [\"unmount\"]);\n\n    var strategy = unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden;\n    return match(strategy, (_match = {}, _match[RenderStrategy.Unmount] = function () {\n      return null;\n    }, _match[RenderStrategy.Hidden] = function () {\n      return _render(_extends({}, _rest, {\n        hidden: true,\n        style: {\n          display: 'none'\n        }\n      }), slot, defaultTag, name);\n    }, _match));\n  } // No features enabled, just render\n\n\n  return _render(props, slot, defaultTag, name);\n}\n\nfunction _render(props, slot, tag, name) {\n  var _ref2;\n\n  if (slot === void 0) {\n    slot = {};\n  }\n\n  var _omit = omit(props, ['unmount', 'static']),\n      _omit$as = _omit.as,\n      Component = _omit$as === void 0 ? tag : _omit$as,\n      children = _omit.children,\n      _omit$refName = _omit.refName,\n      refName = _omit$refName === void 0 ? 'ref' : _omit$refName,\n      passThroughProps = _objectWithoutPropertiesLoose(_omit, [\"as\", \"children\", \"refName\"]); // This allows us to use `<HeadlessUIComponent as={MyComponent} refName=\"innerRef\" />`\n\n\n  var refRelatedProps = props.ref !== undefined ? (_ref2 = {}, _ref2[refName] = props.ref, _ref2) : {};\n  var resolvedChildren = typeof children === 'function' ? children(slot) : children; // Allow for className to be a function with the slot as the contents\n\n  if (passThroughProps.className && typeof passThroughProps.className === 'function') {\n    passThroughProps.className = passThroughProps.className(slot);\n  }\n\n  if (Component === Fragment) {\n    if (Object.keys(passThroughProps).length > 0) {\n      if (!isValidElement(resolvedChildren) || Array.isArray(resolvedChildren) && resolvedChildren.length > 1) {\n        throw new Error(['Passing props on \"Fragment\"!', '', \"The current component <\" + name + \" /> is rendering a \\\"Fragment\\\".\", \"However we need to passthrough the following props:\", Object.keys(passThroughProps).map(function (line) {\n          return \"  - \" + line;\n        }).join('\\n'), '', 'You can apply a few solutions:', ['Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".', 'Render a single element as the child so that we can forward the props onto that element.'].map(function (line) {\n          return \"  - \" + line;\n        }).join('\\n')].join('\\n'));\n      }\n\n      return cloneElement(resolvedChildren, Object.assign({}, // Filter out undefined values so that they don't override the existing values\n      mergeEventFunctions(compact(omit(passThroughProps, ['ref'])), resolvedChildren.props, ['onClick']), refRelatedProps));\n    }\n  }\n\n  return createElement(Component, Object.assign({}, omit(passThroughProps, ['ref']), Component !== Fragment && refRelatedProps), resolvedChildren);\n}\n/**\r\n * We can use this function for the following useCase:\r\n *\r\n * <Menu.Item> <button onClick={console.log} /> </Menu.Item>\r\n *\r\n * Our `Menu.Item` will have an internal `onClick`, if you passthrough an `onClick` to the actual\r\n * `Menu.Item` component we will call it correctly. However, when we have an `onClick` on the actual\r\n * first child, that one should _also_ be called (but before this implementation, it was just\r\n * overriding the `onClick`). But it is only when we *render* that we have access to the existing\r\n * props of this component.\r\n *\r\n * It's a bit hacky, and not that clean, but it is something internal and we have tests to rely on\r\n * so that we can refactor this later (if needed).\r\n */\n\n\nfunction mergeEventFunctions(passThroughProps, existingProps, functionsToMerge) {\n  var clone = Object.assign({}, passThroughProps);\n\n  var _loop = function _loop() {\n    var func = _step.value;\n\n    if (passThroughProps[func] !== undefined && existingProps[func] !== undefined) {\n      var _Object$assign;\n\n      Object.assign(clone, (_Object$assign = {}, _Object$assign[func] = function (event) {\n        // Props we control\n        if (!event.defaultPrevented) passThroughProps[func](event); // Existing props on the component\n\n        if (!event.defaultPrevented) existingProps[func](event);\n      }, _Object$assign));\n    }\n  };\n\n  for (var _iterator = _createForOfIteratorHelperLoose(functionsToMerge), _step; !(_step = _iterator()).done;) {\n    _loop();\n  }\n\n  return clone;\n}\n/**\r\n * This is a hack, but basically we want to keep the full 'API' of the component, but we do want to\r\n * wrap it in a forwardRef so that we _can_ passthrough the ref\r\n */\n\n\nfunction forwardRefWithAs(component) {\n  var _component$displayNam;\n\n  return Object.assign(forwardRef(component), {\n    displayName: (_component$displayNam = component.displayName) != null ? _component$displayNam : component.name\n  });\n}\n\nfunction compact(object) {\n  var clone = Object.assign({}, object);\n\n  for (var key in clone) {\n    if (clone[key] === undefined) delete clone[key];\n  }\n\n  return clone;\n}\n\nfunction omit(object, keysToOmit) {\n  if (keysToOmit === void 0) {\n    keysToOmit = [];\n  }\n\n  var clone = Object.assign({}, object);\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(keysToOmit), _step2; !(_step2 = _iterator2()).done;) {\n    var key = _step2.value;\n    if (key in clone) delete clone[key];\n  }\n\n  return clone;\n}\n\nexport { Features, RenderStrategy, forwardRefWithAs, render };","map":{"version":3,"sources":["/Users/rbrignall/Documents/GitHub/numble/node_modules/@headlessui/react/src/utils/render.ts"],"names":["Features","RenderStrategy","render","props","slot","defaultTag","features","visible","name","_render","featureFlags","isStatic","rest","unmount","strategy","match","hidden","style","display","as","Component","tag","children","refName","passThroughProps","omit","refRelatedProps","resolvedChildren","Object","isValidElement","Array","cloneElement","mergeEventFunctions","compact","createElement","clone","func","existingProps","event","forwardRefWithAs","component","forwardRef","displayName","keysToOmit","key"],"mappings":"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","sourcesContent":["import {\n  Fragment,\n  cloneElement,\n  createElement,\n  forwardRef,\n  isValidElement,\n\n  // Types\n  ElementType,\n  ReactElement,\n} from 'react'\nimport { Props, XOR, __, Expand } from '../types'\nimport { match } from './match'\n\nexport enum Features {\n  /** No features at all */\n  None = 0,\n\n  /**\n   * When used, this will allow us to use one of the render strategies.\n   *\n   * **The render strategies are:**\n   *    - **Unmount**   _(Will unmount the component.)_\n   *    - **Hidden**    _(Will hide the component using the [hidden] attribute.)_\n   */\n  RenderStrategy = 1,\n\n  /**\n   * When used, this will allow the user of our component to be in control. This can be used when\n   * you want to transition based on some state.\n   */\n  Static = 2,\n}\n\nexport enum RenderStrategy {\n  Unmount,\n  Hidden,\n}\n\ntype PropsForFeature<TPassedInFeatures extends Features, TForFeature extends Features, TProps> = {\n  [P in TPassedInFeatures]: P extends TForFeature ? TProps : __\n}[TPassedInFeatures]\n\nexport type PropsForFeatures<T extends Features> = XOR<\n  PropsForFeature<T, Features.Static, { static?: boolean }>,\n  PropsForFeature<T, Features.RenderStrategy, { unmount?: boolean }>\n>\n\nexport function render<TFeature extends Features, TTag extends ElementType, TSlot>({\n  props,\n  slot,\n  defaultTag,\n  features,\n  visible = true,\n  name,\n}: {\n  props: Expand<Props<TTag, TSlot, any> & PropsForFeatures<TFeature>>\n  slot?: TSlot\n  defaultTag: ElementType\n  features?: TFeature\n  visible?: boolean\n  name: string\n}) {\n  // Visible always render\n  if (visible) return _render(props, slot, defaultTag, name)\n\n  let featureFlags = features ?? Features.None\n\n  if (featureFlags & Features.Static) {\n    let { static: isStatic = false, ...rest } = props as PropsForFeatures<Features.Static>\n\n    // When the `static` prop is passed as `true`, then the user is in control, thus we don't care about anything else\n    if (isStatic) return _render(rest, slot, defaultTag, name)\n  }\n\n  if (featureFlags & Features.RenderStrategy) {\n    let { unmount = true, ...rest } = props as PropsForFeatures<Features.RenderStrategy>\n    let strategy = unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden\n\n    return match(strategy, {\n      [RenderStrategy.Unmount]() {\n        return null\n      },\n      [RenderStrategy.Hidden]() {\n        return _render(\n          { ...rest, ...{ hidden: true, style: { display: 'none' } } },\n          slot,\n          defaultTag,\n          name\n        )\n      },\n    })\n  }\n\n  // No features enabled, just render\n  return _render(props, slot, defaultTag, name)\n}\n\nfunction _render<TTag extends ElementType, TSlot>(\n  props: Props<TTag, TSlot> & { ref?: unknown },\n  slot: TSlot = {} as TSlot,\n  tag: ElementType,\n  name: string\n) {\n  let { as: Component = tag, children, refName = 'ref', ...passThroughProps } = omit(props, [\n    'unmount',\n    'static',\n  ])\n\n  // This allows us to use `<HeadlessUIComponent as={MyComponent} refName=\"innerRef\" />`\n  let refRelatedProps = props.ref !== undefined ? { [refName]: props.ref } : {}\n\n  let resolvedChildren = (typeof children === 'function' ? children(slot) : children) as\n    | ReactElement\n    | ReactElement[]\n\n  // Allow for className to be a function with the slot as the contents\n  if (passThroughProps.className && typeof passThroughProps.className === 'function') {\n    ;(passThroughProps as any).className = passThroughProps.className(slot)\n  }\n\n  if (Component === Fragment) {\n    if (Object.keys(passThroughProps).length > 0) {\n      if (\n        !isValidElement(resolvedChildren) ||\n        (Array.isArray(resolvedChildren) && resolvedChildren.length > 1)\n      ) {\n        throw new Error(\n          [\n            'Passing props on \"Fragment\"!',\n            '',\n            `The current component <${name} /> is rendering a \"Fragment\".`,\n            `However we need to passthrough the following props:`,\n            Object.keys(passThroughProps)\n              .map(line => `  - ${line}`)\n              .join('\\n'),\n            '',\n            'You can apply a few solutions:',\n            [\n              'Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".',\n              'Render a single element as the child so that we can forward the props onto that element.',\n            ]\n              .map(line => `  - ${line}`)\n              .join('\\n'),\n          ].join('\\n')\n        )\n      }\n\n      return cloneElement(\n        resolvedChildren,\n        Object.assign(\n          {},\n          // Filter out undefined values so that they don't override the existing values\n          mergeEventFunctions(compact(omit(passThroughProps, ['ref'])), resolvedChildren.props, [\n            'onClick',\n          ]),\n          refRelatedProps\n        )\n      )\n    }\n  }\n\n  return createElement(\n    Component,\n    Object.assign({}, omit(passThroughProps, ['ref']), Component !== Fragment && refRelatedProps),\n    resolvedChildren\n  )\n}\n\n/**\n * We can use this function for the following useCase:\n *\n * <Menu.Item> <button onClick={console.log} /> </Menu.Item>\n *\n * Our `Menu.Item` will have an internal `onClick`, if you passthrough an `onClick` to the actual\n * `Menu.Item` component we will call it correctly. However, when we have an `onClick` on the actual\n * first child, that one should _also_ be called (but before this implementation, it was just\n * overriding the `onClick`). But it is only when we *render* that we have access to the existing\n * props of this component.\n *\n * It's a bit hacky, and not that clean, but it is something internal and we have tests to rely on\n * so that we can refactor this later (if needed).\n */\nfunction mergeEventFunctions(\n  passThroughProps: Record<string, any>,\n  existingProps: Record<string, any>,\n  functionsToMerge: string[]\n) {\n  let clone = Object.assign({}, passThroughProps)\n  for (let func of functionsToMerge) {\n    if (passThroughProps[func] !== undefined && existingProps[func] !== undefined) {\n      Object.assign(clone, {\n        [func](event: { defaultPrevented: boolean }) {\n          // Props we control\n          if (!event.defaultPrevented) passThroughProps[func](event)\n\n          // Existing props on the component\n          if (!event.defaultPrevented) existingProps[func](event)\n        },\n      })\n    }\n  }\n\n  return clone\n}\n\n/**\n * This is a hack, but basically we want to keep the full 'API' of the component, but we do want to\n * wrap it in a forwardRef so that we _can_ passthrough the ref\n */\nexport function forwardRefWithAs<T extends { name: string; displayName?: string }>(\n  component: T\n): T & { displayName: string } {\n  return Object.assign(forwardRef((component as unknown) as any) as any, {\n    displayName: component.displayName ?? component.name,\n  })\n}\n\nfunction compact<T extends Record<any, any>>(object: T) {\n  let clone = Object.assign({}, object)\n  for (let key in clone) {\n    if (clone[key] === undefined) delete clone[key]\n  }\n  return clone\n}\n\nfunction omit<T extends Record<any, any>>(object: T, keysToOmit: string[] = []) {\n  let clone = Object.assign({}, object)\n  for (let key of keysToOmit) {\n    if (key in clone) delete clone[key]\n  }\n  return clone\n}\n"]},"metadata":{},"sourceType":"module"}