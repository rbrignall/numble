{"ast":null,"code":"import { createForOfIteratorHelperLoose as _createForOfIteratorHelperLoose } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport { useRef, useEffect } from 'react';\nimport { Keys } from '../components/keyboard.esm.js';\nimport { focusElement, focusIn, Focus, FocusResult } from '../utils/focus-management.esm.js';\nimport { useWindowEvent } from './use-window-event.esm.js';\nimport { useIsMounted } from './use-is-mounted.esm.js';\nvar Features;\n\n(function (Features) {\n  /** No features enabled for the `useFocusTrap` hook. */\n  Features[Features[\"None\"] = 1] = \"None\";\n  /** Ensure that we move focus initially into the container. */\n\n  Features[Features[\"InitialFocus\"] = 2] = \"InitialFocus\";\n  /** Ensure that pressing `Tab` and `Shift+Tab` is trapped within the container. */\n\n  Features[Features[\"TabLock\"] = 4] = \"TabLock\";\n  /** Ensure that programmatically moving focus outside of the container is disallowed. */\n\n  Features[Features[\"FocusLock\"] = 8] = \"FocusLock\";\n  /** Ensure that we restore the focus when unmounting the component that uses this `useFocusTrap` hook. */\n\n  Features[Features[\"RestoreFocus\"] = 16] = \"RestoreFocus\";\n  /** Enable all features. */\n\n  Features[Features[\"All\"] = 30] = \"All\";\n})(Features || (Features = {}));\n\nfunction useFocusTrap(container, features, _temp) {\n  if (features === void 0) {\n    features = Features.All;\n  }\n\n  var _ref = _temp === void 0 ? {} : _temp,\n      initialFocus = _ref.initialFocus,\n      containers = _ref.containers;\n\n  var restoreElement = useRef(typeof window !== 'undefined' ? document.activeElement : null);\n  var previousActiveElement = useRef(null);\n  var mounted = useIsMounted();\n  var featuresRestoreFocus = Boolean(features & Features.RestoreFocus);\n  var featuresInitialFocus = Boolean(features & Features.InitialFocus); // Capture the currently focused element, before we enable the focus trap.\n\n  useEffect(function () {\n    if (!featuresRestoreFocus) return;\n    restoreElement.current = document.activeElement;\n  }, [featuresRestoreFocus]); // Restore the focus when we unmount the component.\n\n  useEffect(function () {\n    if (!featuresRestoreFocus) return;\n    return function () {\n      focusElement(restoreElement.current);\n      restoreElement.current = null;\n    };\n  }, [featuresRestoreFocus]); // Handle initial focus\n\n  useEffect(function () {\n    if (!featuresInitialFocus) return;\n    if (!container.current) return;\n    var activeElement = document.activeElement;\n\n    if (initialFocus == null ? void 0 : initialFocus.current) {\n      if ((initialFocus == null ? void 0 : initialFocus.current) === activeElement) {\n        previousActiveElement.current = activeElement;\n        return; // Initial focus ref is already the active element\n      }\n    } else if (container.current.contains(activeElement)) {\n      previousActiveElement.current = activeElement;\n      return; // Already focused within Dialog\n    } // Try to focus the initialFocus ref\n\n\n    if (initialFocus == null ? void 0 : initialFocus.current) {\n      focusElement(initialFocus.current);\n    } else {\n      if (focusIn(container.current, Focus.First) === FocusResult.Error) {\n        console.warn('There are no focusable elements inside the <FocusTrap />');\n      }\n    }\n\n    previousActiveElement.current = document.activeElement;\n  }, [container, initialFocus, featuresInitialFocus]); // Handle `Tab` & `Shift+Tab` keyboard events\n\n  useWindowEvent('keydown', function (event) {\n    if (!(features & Features.TabLock)) return;\n    if (!container.current) return;\n    if (event.key !== Keys.Tab) return;\n    event.preventDefault();\n\n    if (focusIn(container.current, (event.shiftKey ? Focus.Previous : Focus.Next) | Focus.WrapAround) === FocusResult.Success) {\n      previousActiveElement.current = document.activeElement;\n    }\n  }); // Prevent programmatically escaping the container\n\n  useWindowEvent('focus', function (event) {\n    if (!(features & Features.FocusLock)) return;\n    var allContainers = new Set(containers == null ? void 0 : containers.current);\n    allContainers.add(container);\n    if (!allContainers.size) return;\n    var previous = previousActiveElement.current;\n    if (!previous) return;\n    if (!mounted.current) return;\n    var toElement = event.target;\n\n    if (toElement && toElement instanceof HTMLElement) {\n      if (!contains(allContainers, toElement)) {\n        event.preventDefault();\n        event.stopPropagation();\n        focusElement(previous);\n      } else {\n        previousActiveElement.current = toElement;\n        focusElement(toElement);\n      }\n    } else {\n      focusElement(previousActiveElement.current);\n    }\n  }, true);\n}\n\nfunction contains(containers, element) {\n  for (var _iterator = _createForOfIteratorHelperLoose(containers), _step; !(_step = _iterator()).done;) {\n    var _container$current;\n\n    var container = _step.value;\n    if ((_container$current = container.current) == null ? void 0 : _container$current.contains(element)) return true;\n  }\n\n  return false;\n}\n\nexport { Features, useFocusTrap };","map":{"version":3,"sources":["/Users/rbrignall/Documents/GitHub/numble/node_modules/@headlessui/react/src/hooks/use-focus-trap.ts"],"names":["Features","useFocusTrap","container","features","All","initialFocus","containers","restoreElement","useRef","document","previousActiveElement","mounted","useIsMounted","featuresRestoreFocus","Boolean","featuresInitialFocus","useEffect","focusElement","activeElement","focusIn","Focus","FocusResult","console","useWindowEvent","event","Keys","allContainers","previous","toElement","contains"],"mappings":"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","sourcesContent":["import {\n  useRef,\n  // Types\n  MutableRefObject,\n  useEffect,\n} from 'react'\n\nimport { Keys } from '../components/keyboard'\nimport { focusElement, focusIn, Focus, FocusResult } from '../utils/focus-management'\nimport { useWindowEvent } from './use-window-event'\nimport { useIsMounted } from './use-is-mounted'\n\nexport enum Features {\n  /** No features enabled for the `useFocusTrap` hook. */\n  None = 1 << 0,\n\n  /** Ensure that we move focus initially into the container. */\n  InitialFocus = 1 << 1,\n\n  /** Ensure that pressing `Tab` and `Shift+Tab` is trapped within the container. */\n  TabLock = 1 << 2,\n\n  /** Ensure that programmatically moving focus outside of the container is disallowed. */\n  FocusLock = 1 << 3,\n\n  /** Ensure that we restore the focus when unmounting the component that uses this `useFocusTrap` hook. */\n  RestoreFocus = 1 << 4,\n\n  /** Enable all features. */\n  All = InitialFocus | TabLock | FocusLock | RestoreFocus,\n}\n\nexport function useFocusTrap(\n  container: MutableRefObject<HTMLElement | null>,\n  features: Features = Features.All,\n  {\n    initialFocus,\n    containers,\n  }: {\n    initialFocus?: MutableRefObject<HTMLElement | null>\n    containers?: MutableRefObject<Set<MutableRefObject<HTMLElement | null>>>\n  } = {}\n) {\n  let restoreElement = useRef<HTMLElement | null>(\n    typeof window !== 'undefined' ? (document.activeElement as HTMLElement) : null\n  )\n  let previousActiveElement = useRef<HTMLElement | null>(null)\n  let mounted = useIsMounted()\n\n  let featuresRestoreFocus = Boolean(features & Features.RestoreFocus)\n  let featuresInitialFocus = Boolean(features & Features.InitialFocus)\n\n  // Capture the currently focused element, before we enable the focus trap.\n  useEffect(() => {\n    if (!featuresRestoreFocus) return\n\n    restoreElement.current = document.activeElement as HTMLElement\n  }, [featuresRestoreFocus])\n\n  // Restore the focus when we unmount the component.\n  useEffect(() => {\n    if (!featuresRestoreFocus) return\n\n    return () => {\n      focusElement(restoreElement.current)\n      restoreElement.current = null\n    }\n  }, [featuresRestoreFocus])\n\n  // Handle initial focus\n  useEffect(() => {\n    if (!featuresInitialFocus) return\n    if (!container.current) return\n\n    let activeElement = document.activeElement as HTMLElement\n\n    if (initialFocus?.current) {\n      if (initialFocus?.current === activeElement) {\n        previousActiveElement.current = activeElement\n        return // Initial focus ref is already the active element\n      }\n    } else if (container.current.contains(activeElement)) {\n      previousActiveElement.current = activeElement\n      return // Already focused within Dialog\n    }\n\n    // Try to focus the initialFocus ref\n    if (initialFocus?.current) {\n      focusElement(initialFocus.current)\n    } else {\n      if (focusIn(container.current, Focus.First) === FocusResult.Error) {\n        console.warn('There are no focusable elements inside the <FocusTrap />')\n      }\n    }\n\n    previousActiveElement.current = document.activeElement as HTMLElement\n  }, [container, initialFocus, featuresInitialFocus])\n\n  // Handle `Tab` & `Shift+Tab` keyboard events\n  useWindowEvent('keydown', event => {\n    if (!(features & Features.TabLock)) return\n\n    if (!container.current) return\n    if (event.key !== Keys.Tab) return\n\n    event.preventDefault()\n\n    if (\n      focusIn(\n        container.current,\n        (event.shiftKey ? Focus.Previous : Focus.Next) | Focus.WrapAround\n      ) === FocusResult.Success\n    ) {\n      previousActiveElement.current = document.activeElement as HTMLElement\n    }\n  })\n\n  // Prevent programmatically escaping the container\n  useWindowEvent(\n    'focus',\n    event => {\n      if (!(features & Features.FocusLock)) return\n\n      let allContainers = new Set(containers?.current)\n      allContainers.add(container)\n\n      if (!allContainers.size) return\n\n      let previous = previousActiveElement.current\n      if (!previous) return\n      if (!mounted.current) return\n\n      let toElement = event.target as HTMLElement | null\n\n      if (toElement && toElement instanceof HTMLElement) {\n        if (!contains(allContainers, toElement)) {\n          event.preventDefault()\n          event.stopPropagation()\n          focusElement(previous)\n        } else {\n          previousActiveElement.current = toElement\n          focusElement(toElement)\n        }\n      } else {\n        focusElement(previousActiveElement.current)\n      }\n    },\n    true\n  )\n}\n\nfunction contains(containers: Set<MutableRefObject<HTMLElement | null>>, element: HTMLElement) {\n  for (let container of containers) {\n    if (container.current?.contains(element)) return true\n  }\n\n  return false\n}\n"]},"metadata":{},"sourceType":"module"}